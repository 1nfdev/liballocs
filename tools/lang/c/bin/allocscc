#!/usr/bin/env python

# Compiler wrapper for liballocs.
# We mostly delegate to cilly,passing --save-temps=$( dirname "$inputfile" )
# i.e. to ensure that temporaries get created in the source file's location
# FIXME: This might break some builds using a separate objdir.
# The Right Thing to do is to somehow replicate the source directory structure
# rooted at the current directory. But it's not clear how to do this in general.

import os, sys, re, subprocess, tempfile
# HACK
sys.path.append(os.path.realpath(os.path.dirname(__file__) + "/../../.."))
from allocscompilerwrapper import *

class AllocsCC(AllocsCompilerWrapper):

    def defaultL1AllocFns(self):
        return ["malloc(Z)p", "calloc(zZ)p", "realloc(pZ)p", "memalign(zZ)p"]

    def defaultFreeFns(self):
        return ["free(P)"]

    def getCustomCompileArgs(self, sourceInputFiles):
        saveTempsArgs = ['-save-temps']
        for sourceFile in sourceInputFiles:
            dirname = os.path.dirname(sourceFile)
            # FIXME: support multiple distinct directories here, if cilly can
            if dirname != "":
                 saveTempsArgs = ["--save-temps=" + dirname]
        return AllocsCompilerWrapper.getCustomCompileArgs(self, sourceInputFiles) \
        + saveTempsArgs
    
    def makeObjectFileName(self, sourceFile):
            nameStem, nameExtension = os.path.splitext(sourceFile)
            if (nameExtension == ".c"):
                outputFilename = nameStem + ".o"
                self.debugMsg("Making a secret output file (from .c source) " + outputFilename + "\n")
            else:
                outputFilename = sourceFile + ".o"
                self.debugMsg("Making a secret output file (from unknown source) " + outputFilename + "\n")
            return outputFilename

    def getCillyArgs(self, sourceFiles):
        # allocscc uses this unmodified (we're not an abstract base).
        # PROBLEM: we only want to -include if we're compiling a C file. 
        # Note that normally cilly will figure out when we're compiling
        # a .S file, say, and only pass options that are relevant. But
        # it would be asking too much in this case. 
        
        allSourceFilesAreC = True
        for sourceFile in sourceFiles:
            if not sourceFile.endswith(".c"):
                allSourceFilesAreC = False
        
        includeArgs = []
        if allSourceFilesAreC:
            includeArgs = ["-include", os.path.dirname(__file__) + "/../../../../include/liballocs_cil_inlines.h"]
        else:
            pass
        
        return [\
        "--load=%s" % (self.getLibAllocsBaseDir() + "tools/lang/c/dumpallocs/dumpallocs.cmxs"), \
         "--load=%s" % (self.getLibAllocsBaseDir() + "tools/lang/c/monalloca/monalloca.cmxs"), \
           "--dodumpallocs", "--domonalloca", \
            "--keepunused"] \
            + includeArgs + \
            ["-Wno-unused-variable", "-Wno-unused-label"]
            # We need the above -Wno-unused-... because CIL creates
            # some unused stuff (unavoidably, I believe) which will
            # make compilation done with -Werror barf if we don't
            # silence them.
    
    def getUnderlyingCompilerCommand(self, sourceFiles):
        return ["cilly"] + self.getCillyArgs(sourceFiles)

if __name__ == '__main__':
    wrapper = AllocsCC()
    ret = wrapper.main()
    exit(ret)

