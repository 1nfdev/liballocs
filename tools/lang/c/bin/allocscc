#!/usr/bin/env python

# Compiler wrapper for liballocs.
# We mostly delegate to cilly,passing --save-temps=$( dirname "$inputfile" )
# i.e. to ensure that temporaries get created in the source file's location
# FIXME: This might break some builds using a separate objdir.
# The Right Thing to do is to somehow replicate the source directory structure
# rooted at the current directory. But it's not clear how to do this in general.

import os, sys, re, subprocess, tempfile
# HACK
sys.path.append(os.path.realpath(os.path.dirname(__file__) + "/../../.."))
from allocscompilerwrapper import *

class AllocsCC(AllocsCompilerWrapper):

    def defaultL1AllocFns(self):
        return ["malloc(Z)p", "calloc(zZ)p", "realloc(pZ)p", "memalign(zZ)p"]

    def defaultFreeFns(self):
        return ["free(P)"]

    def getCustomCompileArgs(self, sourceInputFiles):
        saveTempsArgs = ['-save-temps']
        for sourceFile in sourceInputFiles:
            dirname = os.path.dirname(sourceFile)
            # FIXME: support multiple distinct directories here, if cilly can
            if dirname != "":
                 saveTempsArgs = ["--save-temps=" + dirname]
        return AllocsCompilerWrapper.getCustomCompileArgs(self, sourceInputFiles) \
        + saveTempsArgs
    
    def makeObjectFileName(self, sourceFile):
            nameStem, nameExtension = os.path.splitext(sourceFile)
            if (nameExtension == ".c"):
                outputFilename = nameStem + ".o"
                sys.stderr.write("Making a secret output file (from .c source) " + outputFilename + "\n")
            else:
                outputFilename = sourceFile + ".o"
                sys.stderr.write("Making a secret output file (from unknown source) " + outputFilename + "\n")
            return outputFilename

    def getCillyArgs(self):
        # allocscc uses this unmodified (we're not an abstract base)
        return ["--load=%s" % \
        (self.getLibAllocsBaseDir() + "tools/lang/c/dumpallocs/dumpallocs.cmxs"), "--dodumpallocs"]
    
    def getUnderlyingCompilerCommand(self):
        return ["cilly"] + self.getCillyArgs()

if __name__ == '__main__':
    wrapper = AllocsCC()
    ret = wrapper.main()
    exit(ret)

